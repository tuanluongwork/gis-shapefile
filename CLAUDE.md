This codebase implements a C++-based GIS (Geographic Information System) application that reads shapefiles, performs geocoding, and exposes this functionality through a simple HTTP server. Here is a detailed breakdown of the solution:

### Project Structure and Core Components

The project is organized into several directories, each with a specific responsibility:

-   **`src/`**: Contains the core logic of the GIS application.
    -   **`shapefile/`**: Handles reading and parsing of ESRI shapefiles.
    -   **`geocoding/`**: Implements reverse geocoding functionality.
    -   **`spatial/`**: Contains data structures for efficient spatial querying, like an R-Tree.
-   **`server/`**: Implements a basic HTTP server to expose the GIS functionality as a web service.
-   **`include/`**: Public header files for the `gis-core` library.
-   **`log-services/`**: A dedicated, configurable logging service built on top of `spdlog`.
-   **`data/`**: Contains sample shapefile data for the United States.
-   **`build/` and `build-new/`**: Build directories generated by CMake.
-   **`elk-services/`**: Contains Docker Compose configuration for setting up an ELK (Elasticsearch, Logstash, Kibana) stack for log aggregation and visualization.

### Core Library: `gis-core`

This static library encapsulates the main business logic of the application.

1.  **Shapefile Parsing (`src/shapefile/`)**:
    -   `shapefile_reader.cpp`: This is the heart of the data ingestion process. It reads `.shp` and `.dbf` files.
        -   It parses the main file header to get information about the shapefile, such as the type of shapes it contains (points, polylines, polygons).
        -   It reads the shape records from the `.shp` file, which contain the geometric data.
        -   It reads the attribute records from the `.dbf` file, which contain metadata for each shape (e.g., country name, state name).
        -   It combines the geometry and attributes into a single `Shape` object.
    -   `geometry.cpp`: Defines the geometric primitives like `Point`, `Box`, and `Polygon`.

2.  **Spatial Indexing (`src/spatial/`)**:
    -   `spatial_index.cpp`: To efficiently find which polygon contains a given point (the core of reverse geocoding), a spatial index is necessary. This component likely implements a data structure like an R-Tree or a Quadtree. When the shapefile is loaded, all the polygons are inserted into this index. A query with a point (latitude, longitude) can then very quickly find the containing polygon without having to check every single polygon in the dataset.

3.  **Geocoding (`src/geocoding/`)**:
    -   `geocoder.cpp`: This component uses the spatial index to perform reverse geocoding.
        -   It takes a latitude and longitude as input.
        -   It queries the spatial index to find the shape (polygon) that contains this point.
        -   It then returns the attributes associated with that shape, such as the state and county name.

### Web Service: `gis-server`

The `gis-server` is an executable that provides a web API for the `gis-core` library's functionality.

-   **HTTP Server (`server/http_server.cpp`, `server/http_server.h`)**:
    -   A minimal, custom-built HTTP server is implemented to handle incoming requests. It's a simple, single-threaded server designed for demonstration purposes. It listens on a specified port and can be started and stopped.
-   **API Endpoint (`server/main.cpp`)**:
    -   The `main` function initializes the `ShapefileReader`, loads the data, builds the `SpatialIndex`, and creates the `Geocoder`.
    -   It then starts the `HttpServer` and registers a request handler.
    -   The handler parses the URL to identify the requested endpoint. It likely implements a `/reverse` endpoint that accepts `lat` and `lng` query parameters.
    -   When a request comes to `/reverse`, it calls the `Geocoder` to find the location information and returns it as a JSON response.

### Logging Subsystem (`log-services/`)

The application features a sophisticated, asynchronous logging system.

-   **`spdlog` Integration**: It uses the popular `spdlog` library as its backend.
-   **YAML Configuration**: The logging behavior (log level, output format, file rotation) is configured through a `logging.yaml` file. This allows for changing logging behavior without recompiling the application.
-   **Asynchronous Logging**: To minimize performance impact on the main application threads, logging is done asynchronously in a separate background thread.
-   **Correlation ID**: A `CorrelationID` class is used to track a single request as it flows through different parts of the system. A unique ID is generated for each incoming HTTP request and is included in all log messages related to that request. This is invaluable for debugging in a concurrent environment.
-   **Log Rotation**: The system is configured to rotate log files based on size and time (e.g., daily), preventing log files from growing indefinitely.

### Build System (CMake)

-   `CMakeLists.txt` defines the build process.
-   It uses `FetchContent` to automatically download and build dependencies (`spdlog`, `yaml-cpp`) if they are not found on the system. This makes the project easy to set up and build.
-   It defines the `gis-core` library and the `gis-server` executable, linking them together correctly.
-   It handles platform-specific details, such as linking network libraries on Windows.

### ELK Stack Integration (`elk-services/`)

The presence of an `elk-services` directory with a `docker-compose.yml` file indicates that the application's logs are intended to be shipped to an ELK stack for centralized analysis and visualization. The logging format is likely JSON, which can be easily parsed by Logstash. This setup is common for production-grade services to enable powerful log searching, filtering, and dashboarding in Kibana.

### Summary of Solution

This project is a well-architected C++ application that demonstrates modern software engineering principles.

-   **Separation of Concerns**: The core logic (`gis-core`) is decoupled from the presentation layer (`gis-server`).
-   **Modern C++**: It uses C++17 features and standard library components.
-   **Dependency Management**: Modern CMake with `FetchContent` simplifies the build process.
-   **Performance**: The use of a spatial index and asynchronous logging shows a focus on performance.
-   **Observability**: The advanced logging system with correlation IDs and ELK stack integration provides excellent observability into the application's behavior.
-   **Configuration**: External YAML configuration for logging allows for flexibility.

In essence, the application loads geographic data from a shapefile, builds an efficient in-memory spatial index, and then uses a simple web server to offer a reverse geocoding API. It is designed to be robust, performant, and easy to monitor.
