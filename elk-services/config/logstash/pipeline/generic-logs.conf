input {
  # Generic file input for log collection
  file {
    path => [
      "/usr/share/logstash/logs/*",
      "/usr/share/logstash/logs/**/*"
    ]
    start_position => "beginning"
    codec => "${LOG_CODEC:json_lines}"
    tags => ["${LOG_TYPE:application}", "${APPLICATION_NAME:myapp}"]
    type => "${LOG_TYPE:application}"
  }

  # Optional: Beats input for Filebeat integration
  beats {
    port => 5044
  }
}

filter {
  # Handle JSON formatted logs
  if [codec] == "json_lines" or "${LOG_FORMAT}" == "json" {
    # Parse JSON if message is JSON formatted
    if [message] =~ /^{.*}$/ {
      json {
        source => "message"
        skip_on_invalid_json => true
      }
    }
  }

  # Handle plain text logs with custom patterns
  if [codec] != "json_lines" and "${LOG_FORMAT}" != "json" {
    # Apply custom grok pattern if defined
    if "${CUSTOM_GROK_PATTERN:}" != "" {
      grok {
        match => { "message" => "${CUSTOM_GROK_PATTERN}" }
        tag_on_failure => ["_grok_parse_failure"]
      }
    } else {
      # Default pattern for common log formats
      grok {
        match => { 
          "message" => [
            "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:message}",
            "%{COMMONAPACHELOG}",
            "%{SYSLOGTIMESTAMP:timestamp} %{IPORHOST:host} %{PROG:program}: %{GREEDYDATA:message}"
          ]
        }
        tag_on_failure => ["_grok_parse_failure"]
      }
    }
  }

  # Extract correlation ID if pattern is defined
  if "${CORRELATION_ID_PATTERN:}" != "" {
    grok {
      match => { "message" => "${CORRELATION_ID_PATTERN}" }
      tag_on_failure => []
    }
  }

  # Extract thread information if pattern is defined
  if "${THREAD_PATTERN:}" != "" {
    grok {
      match => { "message" => "${THREAD_PATTERN}" }
      tag_on_failure => []
    }
  }

  # Parse timestamps
  if [timestamp] {
    date {
      match => [ 
        "timestamp", 
        "ISO8601", 
        "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'",
        "yyyy-MM-dd HH:mm:ss.SSS",
        "MMM dd HH:mm:ss",
        "MMM  d HH:mm:ss"
      ]
      target => "@timestamp"
    }
  }

  # Normalize log level
  if [level] {
    mutate {
      lowercase => ["level"]
    }
    
    # Map common log level variations
    if [level] == "warn" {
      mutate { replace => { "level" => "warning" } }
    }
    if [level] == "err" {
      mutate { replace => { "level" => "error" } }
    }
  }

  # Add common metadata
  mutate {
    add_field => { 
      "[@metadata][index_prefix]" => "${INDEX_PREFIX:app-logs}"
      "application" => "${APPLICATION_NAME:myapp}"
      "log_source" => "filebeat"
      "log_type" => "${LOG_TYPE:application}"
    }
  }

  # Add component from logger name if present
  if [logger] {
    mutate {
      add_field => { "component" => "%{logger}" }
    }
  } else if [program] {
    mutate {
      add_field => { "component" => "%{program}" }
    }
  }

  # Add host information
  if ![host] and [beat] and [beat][hostname] {
    mutate {
      add_field => { "host" => "%{[beat][hostname]}" }
    }
  }

  # Clean up temporary fields
  mutate {
    remove_field => [ "beat", "prospector", "input", "offset", "source" ]
  }

  # Drop empty messages
  if [message] == "" or !([message]) {
    drop { }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][index_prefix]}-%{+${INDEX_DATE_PATTERN:YYYY.MM.dd}}"
    template_name => "%{[@metadata][index_prefix]}"
    template_pattern => "%{[@metadata][index_prefix]}-*"
    template_overwrite => true
    template => {
      "index_patterns" => ["%{[@metadata][index_prefix]}-*"],
      "settings" => {
        "number_of_shards" => 1,
        "number_of_replicas" => 0,
        "index.refresh_interval" => "5s"
      },
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" },
          "level" => { "type" => "keyword" },
          "message" => { "type" => "text" },
          "logger" => { "type" => "keyword" },
          "component" => { "type" => "keyword" },
          "application" => { "type" => "keyword" },
          "log_type" => { "type" => "keyword" },
          "host" => { "type" => "keyword" },
          "correlation_id" => { "type" => "keyword" },
          "thread_id" => { "type" => "keyword" }
        }
      }
    }
  }

  # Debug output (disable in production by setting DEBUG_OUTPUT=false)
  if "${DEBUG_OUTPUT:true}" == "true" {
    stdout {
      codec => rubydebug {
        metadata => true
      }
    }
  }
}