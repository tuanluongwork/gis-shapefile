input {
  # File input for log files
  file {
    path => "/usr/share/logstash/logs/gis-server.log*"
    start_position => "beginning"
    codec => "json"
    tags => ["gis-server", "file"]
  }
  
  # Beats input (Filebeat)
  beats {
    port => 5044
    tags => ["gis-server", "beats"]
  }
  
  # TCP input for direct log shipping
  tcp {
    port => 5000
    codec => json_lines
    tags => ["gis-server", "tcp"]
  }
}

filter {
  # Parse timestamp if it exists
  if [timestamp] {
    date {
      match => [ "timestamp", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "ISO8601" ]
      target => "@timestamp"
    }
  }
  
  # Extract correlation ID and other context fields
  if [message] =~ /correlation_id:/ {
    grok {
      match => { "message" => "%{GREEDYDATA:base_message} \| correlation_id:%{NOTSPACE:correlation_id}%{GREEDYDATA:context_fields}" }
    }
    
    # Parse additional context fields
    if [context_fields] {
      kv {
        source => "context_fields"
        field_split => " "
        value_split => ":"
        target => "context"
      }
    }
    
    # Clean up the message
    mutate {
      replace => { "message" => "%{base_message}" }
      remove_field => [ "base_message", "context_fields" ]
    }
  }
  
  # Add service and environment metadata
  mutate {
    add_field => { "service" => "gis-geocoding-api" }
    add_field => { "environment" => "development" }
    add_field => { "version" => "1.0.0" }
  }
  
  # Parse performance metrics
  if [context][execution_time_ms] {
    mutate {
      convert => { "[context][execution_time_ms]" => "float" }
    }
  }
  
  if [context][memory_usage_mb] {
    mutate {
      convert => { "[context][memory_usage_mb]" => "float" }
    }
  }
  
  if [context][response_time_ms] {
    mutate {
      convert => { "[context][response_time_ms]" => "float" }
    }
  }
  
  # Create performance alert flag for slow operations
  if [context][execution_time_ms] and [context][execution_time_ms] > 1000 {
    mutate {
      add_field => { "alert" => "slow_operation" }
      add_tag => [ "performance_alert" ]
    }
  }
  
  # Add geographic metadata for geocoding operations
  if [logger] == "GeocodingAPI" and [context][input_address] {
    mutate {
      add_field => { "operation_type" => "geocoding" }
    }
  }
}

output {
  # Output to Elasticsearch with index patterns based on service and date
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "gis-logs-%{+YYYY.MM.dd}"
    
    # Template for proper field mappings
    template_name => "gis-logs"
    template_pattern => "gis-logs-*"
    template => {
      "settings" => {
        "number_of_shards" => 1
        "number_of_replicas" => 0
        "index.refresh_interval" => "5s"
      }
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "level" => { "type" => "keyword" }
          "logger" => { "type" => "keyword" }
          "message" => { "type" => "text" }
          "service" => { "type" => "keyword" }
          "environment" => { "type" => "keyword" }
          "correlation_id" => { "type" => "keyword" }
          "context" => {
            "type" => "object"
            "properties" => {
              "fips" => { "type" => "keyword" }
              "job_id" => { "type" => "keyword" }
              "process_step" => { "type" => "keyword" }
              "execution_time_ms" => { "type" => "float" }
              "memory_usage_mb" => { "type" => "float" }
              "response_time_ms" => { "type" => "float" }
              "input_address" => { "type" => "text" }
              "matched_address" => { "type" => "text" }
              "confidence" => { "type" => "float" }
            }
          }
        }
      }
    }
  }
  
  # Debug output to stdout (can be disabled in production)
  stdout {
    codec => rubydebug {
      metadata => false
    }
  }
}